<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>深入理解Objective-C:Category | ZeroDY&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Objective-C:Category">
<meta property="og:url" content="http://yoursite.com/2016/04/11/深入理解Objective-C-Category/index.html">
<meta property="og:site_name" content="ZeroDY's Blogs">
<meta property="og:description" content="摘要无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应">
<meta property="og:image" content="http://tech.meituan.com/img/diveintocategory/project.png">
<meta property="og:image" content="http://tech.meituan.com/img/diveintocategory/environment_vars.png">
<meta property="og:image" content="http://tech.meituan.com/img/diveintocategory/compile1.png">
<meta property="og:image" content="http://tech.meituan.com/img/diveintocategory/compile2.png">
<meta property="og:updated_time" content="2016-06-14T15:38:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Objective-C:Category">
<meta name="twitter:description" content="摘要无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应">
<meta name="twitter:image" content="http://tech.meituan.com/img/diveintocategory/project.png">
  
  
    <link rel="icon" href="http://o7279yd4s.bkt.clouddn.com/bitbug_favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://o7279yd4s.bkt.clouddn.com/IMG_1776.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ZeroDY</a></h1>
		</hgroup>

		
		<p class="header-subtitle">梦想还是要有的，万一见鬼了呢。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
							<!-- <li><a target="_top" href="/about/index.html">主页</a></li> -->
				        
							<li><a href="/archives">所有文章</a></li>
							<!-- <li><a target="_top" href="/about/index.html">所有文章</a></li> -->
				        
							<li><a href="/tags">标签云</a></li>
							<!-- <li><a target="_top" href="/about/index.html">标签云</a></li> -->
				        
							<li><a href="/message">留言板</a></li>
							<!-- <li><a target="_top" href="/about/index.html">留言板</a></li> -->
				        
							<li><a href="/resume/index.html">关于我</a></li>
							<!-- <li><a target="_top" href="/about/index.html">关于我</a></li> -->
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_self" href="https://github.com/ZeroDY" title="github">github</a>
					        
								<a class="weibo" target="_self" href="http://weibo.com/2345900261/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo">weibo</a>
					        
								<a class="rss" target="_self" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Blogs/" style="font-size: 10px;">Blogs</a> <a href="/tags/Category/" style="font-size: 10px;">Category</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/NSAttributedString/" style="font-size: 10px;">NSAttributedString</a> <a href="/tags/ReactiveCocoa/" style="font-size: 10px;">ReactiveCocoa</a> <a href="/tags/UIAppearance/" style="font-size: 10px;">UIAppearance</a> <a href="/tags/UIApplication/" style="font-size: 10px;">UIApplication</a> <a href="/tags/UIScrollView/" style="font-size: 10px;">UIScrollView</a> <a href="/tags/iOS学习/" style="font-size: 15px;">iOS学习</a> <a href="/tags/仿/" style="font-size: 10px;">仿</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/备忘/" style="font-size: 20px;">备忘</a> <a href="/tags/富文本/" style="font-size: 15px;">富文本</a> <a href="/tags/常用代码/" style="font-size: 15px;">常用代码</a> <a href="/tags/手工客/" style="font-size: 10px;">手工客</a> <a href="/tags/技巧/" style="font-size: 10px;">技巧</a> <a href="/tags/离屏渲染/" style="font-size: 10px;">离屏渲染</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ZeroDY</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://o7279yd4s.bkt.clouddn.com/IMG_1776.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">ZeroDY</h1>
			</hgroup>
			
			<p class="header-subtitle">梦想还是要有的，万一见鬼了呢。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签云</a></li>
		        
					<li><a href="/message">留言板</a></li>
		        
					<li><a href="/resume/index.html">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ZeroDY" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2345900261/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-深入理解Objective-C-Category" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/11/深入理解Objective-C-Category/" class="article-date">
  	<time datetime="2016-04-11T07:03:59.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入理解Objective-C:Category
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Category/">Category</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS学习/">iOS学习</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      

          
            <div id="toc" class="toc-article">
              <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#摘要"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1、初入宝地-category简介"><span class="toc-number">3.</span> <span class="toc-text">1、初入宝地-category简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、连类比事-category和extension"><span class="toc-number">4.</span> <span class="toc-text">2、连类比事-category和extension</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、挑灯细览-category真面目"><span class="toc-number">5.</span> <span class="toc-text">3、挑灯细览-category真面目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、追本溯源-category如何加载"><span class="toc-number">6.</span> <span class="toc-text">4、追本溯源-category如何加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、旁枝末叶-category和-load方法"><span class="toc-number">7.</span> <span class="toc-text">5、旁枝末叶-category和+load方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6、触类旁通-category和方法覆盖"><span class="toc-number">8.</span> <span class="toc-text">6、触类旁通-category和方法覆盖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7、更上一层-category和关联对象"><span class="toc-number">9.</span> <span class="toc-text">7、更上一层-category和关联对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后记"><span class="toc-number">10.</span> <span class="toc-text">后记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原文地址：http-tech-meituan-com-DiveIntoCategory-html"><span class="toc-number">10.1.</span> <span class="toc-text">原文地址：http://tech.meituan.com/DiveIntoCategory.html</span></a></li></ol></li></ol>
            </div>
          

          

        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。<br>本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：</p>
<ul>
<li>初入宝地-category简介</li>
<li>连类比事-category和extension</li>
<li>挑灯细览-category真面目</li>
<li>追本溯源-category如何加载</li>
<li>旁枝末叶-category和+load方法</li>
<li>触类旁通-category和方法覆盖</li>
<li>更上一层-category和关联对象</li>
</ul>
<h1 id="1、初入宝地-category简介"><a href="#1、初入宝地-category简介" class="headerlink" title="1、初入宝地-category简介"></a>1、初入宝地-category简介</h1><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="external">1</a></p>
<ul>
<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li>
<li>声明私有方法</li>
</ul>
<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>
<ul>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>
<h1 id="2、连类比事-category和extension"><a href="#2、连类比事-category和extension" class="headerlink" title="2、连类比事-category和extension"></a>2、连类比事-category和extension</h1><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">2</a>）</p>
<p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
<h1 id="3、挑灯细览-category真面目"><a href="#3、挑灯细览-category真面目" class="headerlink" title="3、挑灯细览-category真面目"></a>3、挑灯细览-category真面目</h1><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure>
<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>ok，我们先去写一个category看一下category到底为何物：</p>
<p>MyClass.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>(<span class="title">MyAddition</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyClass.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"MyClass"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>(<span class="title">MyAddition</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"MyAddition"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们使用clang的命令去看看category到底会变成什么：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-rewrite-objc</span> <span class="selector-tag">MyClass</span><span class="selector-class">.m</span></span><br></pre></td></tr></table></figure>
<p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="keyword">struct</span> _objc_method method_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_<span class="built_in">CATEGORY_INSTANCE_METHODS_MyClass_</span>$_MyAddition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"printName"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_MyClass_MyAddition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_prop_list_t*/</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line"><span class="keyword">struct</span> _prop_t prop_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_prop_t),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">struct</span> _class_t OBJC_CLASS_$_MyClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t _OBJC_$_<span class="built_in">CATEGORY_MyClass_</span>$_MyAddition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"MyClass"</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MyClass,</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *)&amp;_OBJC_$_<span class="built_in">CATEGORY_INSTANCE_METHODS_MyClass_</span>$_MyAddition,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_<span class="built_in">CATEGORY_SETUP_</span>$_MyClass_$_MyAddition(<span class="keyword">void</span> ) &#123;</span><br><span class="line">_OBJC_$_<span class="built_in">CATEGORY_MyClass_</span>$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma section(<span class="meta-string">".objc_inithooks$B"</span>, long, read, write)</span></span><br><span class="line">__declspec(allocate(<span class="string">".objc_inithooks$B"</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_<span class="built_in">CATEGORY_SETUP</span>[] = &#123;</span><br><span class="line">(<span class="keyword">void</span> *)&amp;OBJC_<span class="built_in">CATEGORY_SETUP_</span>$_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _class_t *L_OBJC_LABEL_CLASS_$ [<span class="number">1</span>] __attribute__((used, section (<span class="string">"__DATA, __objc_classlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t *L_OBJC_LABEL_<span class="built_in">CATEGORY_</span>$ [<span class="number">1</span>] __attribute__((used, section (<span class="string">"__DATA, __objc_catlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">&amp;_OBJC_$_<span class="built_in">CATEGORY_MyClass_</span>$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<br>1)、首先编译器生成了实例方法列表<em>OBJC</em>$_CATEGORY_INSTANCE_METHODS<em>MyClass</em>$_MyAddition和属性列表<em>OBJC</em>$_PROP_LIST<em>MyClass</em>$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。<br>2)、其次，编译器生成了category本身<em>OBJC</em>$_CATEGORY<em>MyClass</em>$_MyAddition，并用前面生成的列表来初始化category本身。<br>3)、最后，编译器在<strong>DATA段下的</strong>objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL<em>CATEGORY</em>$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。<br>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。</p>
<h1 id="4、追本溯源-category如何加载"><a href="#4、追本溯源-category如何加载" class="headerlink" title="4、追本溯源-category如何加载"></a>4、追本溯源-category如何加载</h1><p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。<br>想了解更多dyld地同学可以移步这里（<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">3</a>）。</p>
<p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> _objc_init(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-<span class="keyword">using</span> image <span class="keyword">is</span> found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // <span class="type">Register</span> <span class="keyword">for</span> unmap first, <span class="keyword">in</span> <span class="keyword">case</span> some +load unmaps something</span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                             <span class="number">1</span>/*batch*/, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span>/*<span class="keyword">not</span> batch*/, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="function"><span class="title">class_t</span> *cls = remapClass(cat-&gt;</span>cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = NULL;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 <span class="function"><span class="title">cat</span>-&gt;</span><span class="keyword">name</span>, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            BOOL classExists = NO;</span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span>protocols </span><br><span class="line">                ||  <span class="function"><span class="title">cat</span>-&gt;</span>instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls)) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</span><br><span class="line">                                 <span class="function"><span class="title">getName</span>(cls), cat-&gt;</span><span class="keyword">name</span>,</span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span>protocols </span><br><span class="line">                <span class="comment">/* ||  cat-&gt;classProperties */</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>isa, hi);</span><br><span class="line">                <span class="function"><span class="title">if</span> (isRealized(cls-&gt;</span>isa)) &#123;</span><br><span class="line">                    <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>isa);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</span><br><span class="line">                                 <span class="function"><span class="title">getName</span>(cls), cat-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。<br>略去PrintConnecting这个用于log的东西，这段代码很容易理解：<br>1)、把category的实例方法、协议以及属性添加到类上<br>2)、把category的类方法和协议添加到类的metaclass上</p>
<p>值得注意的是，在代码中有一小段注释 / <em>|| cat-&gt;classProperties</em> /，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void remethodizeClass(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        const protocol_list_t **newprotos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>,</span><br><span class="line">                         getName(cls), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update methods, properties, protocols</span></span><br><span class="line"></span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line"></span><br><span class="line">        newproperties = buildPropertyList(NULL, cats, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (newproperties) &#123;</span><br><span class="line">            <span class="function"><span class="title">newproperties</span>-&gt;</span><span class="function"><span class="title">next</span> = cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>properties;</span><br><span class="line">            <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">newprotos</span> = buildProtocolList(cats, NULL, cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>protocols);</span><br><span class="line">        <span class="function"><span class="title">if</span> (cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span><span class="function"><span class="title">protocols</span>  &amp;&amp;  cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>protocols != newprotos) &#123;</span><br><span class="line">            _<span class="function"><span class="title">free_internal</span>(cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>protocols);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>protocols = newprotos;</span><br><span class="line"></span><br><span class="line">        _free_internal(cats);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update method caches and vtables</span></span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        <span class="keyword">if</span> (vtableAffected) flushVtables(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                      <span class="built_in">BOOL</span> *inoutVtablesAffected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> isMeta = isMetaClass(cls);</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="built_in">BOOL</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">for (uint32_t m = 0;</span><br><span class="line">             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">             m++)</span><br><span class="line">        &#123;</span><br><span class="line">            SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">           <span class="built_in"> if </span>(scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomRR();</span><br><span class="line">                scanForCustomRR = false;</span><br><span class="line">            &#125; else<span class="built_in"> if </span>(scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomAWZ();</span><br><span class="line">                scanForCustomAWZ = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fill method list<span class="built_in"> array</span><br><span class="line"></span>        new<span class="class">Lists[newCount++] = mlist;</span></span><br><span class="line"><span class="keyword">    .</span></span><br><span class="line"><span class="keyword">    .</span></span><br><span class="line"><span class="keyword">    .</span></span><br><span class="line"></span><br><span class="line">    // Copy old methods to the method list<span class="built_in"> array</span><br><span class="line"></span>    for (i = 0; i &lt; oldCount; i++) &#123;</span><br><span class="line">        new<span class="class">Lists[newCount++] = oldLists[i];</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的有两点：<br>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA<br>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>
<h1 id="5、旁枝末叶-category和-load方法"><a href="#5、旁枝末叶-category和-load方法" class="headerlink" title="5、旁枝末叶-category和+load方法"></a>5、旁枝末叶-category和+load方法</h1><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？<br>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/project.png" alt="项目结构"></p>
<p>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/environment_vars.png" alt="环境变量"></p>
<p>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">REPLACED</span>: -[<span class="symbol">MyClass</span> printName] by category <span class="symbol">Category1</span></span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">REPLACED</span>: -[<span class="symbol">MyClass</span> printName] by category <span class="symbol">Category2</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: class <span class="string">'MyClass'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: category <span class="string">'MyClass(Category1)'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: category <span class="string">'MyClass(Category2)'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span> load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span>(<span class="symbol">Category1</span>) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span>(<span class="symbol">Category2</span>) load]</span><br></pre></td></tr></table></figure></p>
<p>所以，对于上面两个问题，答案是很明显的：<br>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。<br>目前的编译顺序是这样的：</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/compile1.png" alt="编译顺序1"></p>
<p>我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/compile2.png" alt="编译顺序2"><br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">REPLACED</span>: -[<span class="symbol">MyClass</span> printName] by category <span class="symbol">Category2</span></span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">REPLACED</span>: -[<span class="symbol">MyClass</span> printName] by category <span class="symbol">Category1</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: class <span class="string">'MyClass'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: category <span class="string">'MyClass(Category2)'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: category <span class="string">'MyClass(Category1)'</span> scheduled for +load</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span> load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span>(<span class="symbol">Category2</span>) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[<span class="number">1187</span>]: <span class="symbol">LOAD</span>: +[<span class="symbol">MyClass</span>(<span class="symbol">Category1</span>) load]</span><br></pre></td></tr></table></figure></p>
<p>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。<br>这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p>
<h1 id="6、触类旁通-category和方法覆盖"><a href="#6、触类旁通-category和方法覆盖" class="headerlink" title="6、触类旁通-category和方法覆盖"></a>6、触类旁通-category和方法覆盖</h1><p>鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:<br>怎么调用到原来类中被category覆盖掉的方法？<br>对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">currentClass</span> = [<span class="title">MyClass</span> <span class="title">class</span>];</span></span><br><span class="line">MyClass *my = [[MyClass alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentClass) &#123;</span><br><span class="line">    unsigned int methodCount;</span><br><span class="line">    <span class="function"><span class="keyword">Method</span> *<span class="title">methodList</span> =</span> class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    IMP lastImp = <span class="literal">NULL</span>;</span><br><span class="line">    SEL lastSel = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">Method</span> <span class="title">method</span> =</span> methodList[i];</span><br><span class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(<span class="function"><span class="keyword">method</span>)) </span></span><br><span class="line">                                        encoding:NSUTF8StringEncoding];</span><br><span class="line">        <span class="keyword">if</span> ([@<span class="string">"printName"</span> isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">            lastSel = method_getName(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef void (*fn)(id,SEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastImp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fn f = (fn)lastImp;</span><br><span class="line">        f(my,lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7、更上一层-category和关联对象"><a href="#7、更上一层-category和关联对象" class="headerlink" title="7、更上一层-category和关联对象"></a>7、更上一层-category和关联对象</h1><p>如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。</p>
<p>MyClass+Category1.h:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> (<span class="title">Category1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyClass+Category1.m:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass+Category1.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span> (<span class="title">Category1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"load in Category1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                             <span class="string">"name"</span>,</span><br><span class="line">                             name,</span><br><span class="line">                             OBJC_ASSO<span class="built_in">CIATION_COPY</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span>*)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *nameObject = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">return</span> nameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>setInstancesHaveAssociatedObjects(<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>getClass(<span class="keyword">object</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> OSSpinLock _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;               <span class="comment">// associative references:  object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="keyword">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc<span class="number">_</span>destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        Class isa<span class="number">_</span>gen = <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>getClass(obj);</span><br><span class="line">        <span class="keyword">class</span><span class="number">_</span>t *isa = newcls(isa<span class="number">_</span>gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        bool cxx = hasCxxStructors(isa);</span><br><span class="line">        bool assoc = !UseGC &amp;&amp; <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>instancesHaveAssociatedObjects(isa<span class="number">_</span>gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="keyword">object</span><span class="number">_</span>cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UseGC) objc<span class="number">_</span>clear<span class="number">_</span>deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在<a href="http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码" target="_blank" rel="external">http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。</a>。)<br>本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。</p>
<h2 id="原文地址：http-tech-meituan-com-DiveIntoCategory-html"><a href="#原文地址：http-tech-meituan-com-DiveIntoCategory-html" class="headerlink" title="原文地址：http://tech.meituan.com/DiveIntoCategory.html"></a>原文地址：<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">http://tech.meituan.com/DiveIntoCategory.html</a></h2>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/02/ShougongkeDemo(仿“手工客”iOS App)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          ShougongkeDemo(仿“手工客”iOS App)说明
        
      </div>
    </a>
  
  
    <a href="/2016/03/08/离屏渲染/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">离屏渲染</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="深入理解Objective-C-Category" data-title="深入理解Objective-C:Category" data-url="http://yoursite.com/2016/04/11/深入理解Objective-C-Category/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zerody"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 ZeroDY
    	</div>

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
        本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次

      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-77677122-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<div id="totop" style="position:fixed;bottom:30px;right:0px;cursor: pointer;">
<a title="返回顶部"><img src="/img/gotop.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>